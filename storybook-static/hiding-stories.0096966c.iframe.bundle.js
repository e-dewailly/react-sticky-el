"use strict";(self.webpackChunkreact_sticky_el=self.webpackChunkreact_sticky_el||[]).push([[419],{"./stories/hiding.stories.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{HideOnBoundaryHit1:function(){return HideOnBoundaryHit1},HideOnBoundaryHit2:function(){return HideOnBoundaryHit2},HideOnBoundaryHit3:function(){return HideOnBoundaryHit3},HideOnBoundaryHit4:function(){return HideOnBoundaryHit4},__namedExportsOrder:function(){return __namedExportsOrder}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),react__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__),_common__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./stories/common.tsx");__webpack_exports__.default={title:"hideOnBoundaryHit"};const HideOnBoundaryHit1=()=>react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_common__WEBPACK_IMPORTED_MODULE_1__.im,null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"container"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"column"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"scroll-area"},(0,_common__WEBPACK_IMPORTED_MODULE_1__.x_)(!1,0,0,!0)))));HideOnBoundaryHit1.displayName="HideOnBoundaryHit1",HideOnBoundaryHit1.story={name:"no offset"};const HideOnBoundaryHit2=()=>react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_common__WEBPACK_IMPORTED_MODULE_1__.im,null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"container"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"column"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"scroll-area"},(0,_common__WEBPACK_IMPORTED_MODULE_1__.x_)(!1,70,70,!0)))));HideOnBoundaryHit2.displayName="HideOnBoundaryHit2",HideOnBoundaryHit2.story={name:"with offset"};const HideOnBoundaryHit3=()=>react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_common__WEBPACK_IMPORTED_MODULE_1__.im,null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"container"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"column"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"scroll-area"},(0,_common__WEBPACK_IMPORTED_MODULE_1__.x_)(!1,0,0,!1)))));HideOnBoundaryHit3.displayName="HideOnBoundaryHit3",HideOnBoundaryHit3.story={name:"false"};const HideOnBoundaryHit4=()=>{const[useClipPath,setUseClipPath]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_common__WEBPACK_IMPORTED_MODULE_1__.im,null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"container"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"column"},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div",{className:"scroll-area scroll-area--distant",style:useClipPath?{clipPath:"inset(0 0 0 0)"}:void 0},react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p",null,"If the ",react__WEBPACK_IMPORTED_MODULE_0___default().createElement("code",null,"scrollareaElement")," is not at the top of the viewport (shown here with 100px margin), when the sticky element overflows it, it will stay visible (try scrolling)."),react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p",null,"You can use ",react__WEBPACK_IMPORTED_MODULE_0___default().createElement("code",null,"clip-path: inset(0 0 0 0);")," on the"," ",react__WEBPACK_IMPORTED_MODULE_0___default().createElement("code",null,"scrollareaElement")," to solve this but may have unintended consequences."),react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p",null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("label",null,react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input",{type:"checkbox",checked:useClipPath,onChange:()=>setUseClipPath(!useClipPath)}),"Use clip path")),(0,_common__WEBPACK_IMPORTED_MODULE_1__.x_)(!1,0,0,!1)))))};HideOnBoundaryHit4.displayName="HideOnBoundaryHit4",HideOnBoundaryHit4.story={name:"overflow"},HideOnBoundaryHit1.parameters={...HideOnBoundaryHit1.parameters,docs:{...HideOnBoundaryHit1.parameters?.docs,source:{originalSource:'() => <Wrapper>\n    <div className="container">\n      <div className="column">\n        <div className="scroll-area">\n          {createBlocks(false, 0, 0, true)}\n        </div>\n      </div>\n    </div>\n  </Wrapper>',...HideOnBoundaryHit1.parameters?.docs?.source}}},HideOnBoundaryHit2.parameters={...HideOnBoundaryHit2.parameters,docs:{...HideOnBoundaryHit2.parameters?.docs,source:{originalSource:'() => <Wrapper>\n    <div className="container">\n      <div className="column">\n        <div className="scroll-area">\n          {createBlocks(false, 70, 70, true)}\n        </div>\n      </div>\n    </div>\n  </Wrapper>',...HideOnBoundaryHit2.parameters?.docs?.source}}},HideOnBoundaryHit3.parameters={...HideOnBoundaryHit3.parameters,docs:{...HideOnBoundaryHit3.parameters?.docs,source:{originalSource:'() => <Wrapper>\n    <div className="container">\n      <div className="column">\n        <div className="scroll-area">\n          {createBlocks(false, 0, 0, false)}\n        </div>\n      </div>\n    </div>\n  </Wrapper>',...HideOnBoundaryHit3.parameters?.docs?.source}}},HideOnBoundaryHit4.parameters={...HideOnBoundaryHit4.parameters,docs:{...HideOnBoundaryHit4.parameters?.docs,source:{originalSource:'() => {\n  const [useClipPath, setUseClipPath] = useState(false);\n  return <Wrapper>\n      <div className="container">\n        <div className="column">\n          <div className="scroll-area scroll-area--distant" style={useClipPath ? {\n          clipPath: \'inset(0 0 0 0)\'\n        } : undefined}>\n            <p>\n              If the <code>scrollareaElement</code> is not at the top of the\n              viewport (shown here with 100px margin), when the sticky element\n              overflows it, it will stay visible (try scrolling).\n            </p>\n            <p>\n              You can use <code>clip-path: inset(0 0 0 0);</code> on the{\' \'}\n              <code>scrollareaElement</code> to solve this but may have\n              unintended consequences.\n            </p>\n            <p>\n              <label>\n                <input type="checkbox" checked={useClipPath} onChange={() => setUseClipPath(!useClipPath)} />\n                  Use clip path\n                </label>\n            </p>\n            {createBlocks(false, 0, 0, false)}\n          </div>\n        </div>\n      </div>\n    </Wrapper>;\n}',...HideOnBoundaryHit4.parameters?.docs?.source}}};const __namedExportsOrder=["HideOnBoundaryHit1","HideOnBoundaryHit2","HideOnBoundaryHit3","HideOnBoundaryHit4"]}}]);